import Mathlib.Algebra.Group.Commutator
import Mathlib.Algebra.Ring.Defs
import Mathlib.GroupTheory.Commutator.Basic
import Mathlib.GroupTheory.FreeGroup.Basic
import Mathlib.GroupTheory.PresentedGroup

import Steinberg.Defs.Root
import Steinberg.Defs.Chevalley
import Steinberg.Upstream.PresentedGroup

namespace Steinberg

open PosRootSys

variable {G : Type TG} [Group G]
         {Φ : Type TΦ} [PosRootSys Φ]
         {R : Type TR} [Ring R]

macro (name := algebra) "simpset" : tactic => `(tactic| (simp only [Set.mem_insert_iff, Set.mem_union, Set.mem_setOf_eq, Set.mem_singleton_iff, true_or, or_true]))

open GradedGen

structure WeakChevalley (Φ : Type TΦ) [PosRootSys Φ] (R : Type TR) [Ring R] where
  mk ::
  -- autogenerated
  trivial_comm_root_pairs : Set (Φ × Φ)
  single_comm_root_pairs : Set (SingleSpanRootPair Φ R)
  mixed_commutes_roots : Set Φ
  double_comm_root_pairs : Set (DoubleSpanRootPair Φ R)
  lin_roots : Set Φ

  -- problem dependent
  nonhomog_rels_sets : Set (Set (FreeGroupOnGradedGens Φ R))
  def_rels_sets : Set (Set (FreeGroupOnGradedGens Φ R))

namespace WeakChevalley

open Steinberg

open WeakChevalley

private theorem cancel_helper (G : Type TG) [Group G] (x y z : G) : x * y * z⁻¹ = 1 → x * y = z := by
  intro h
  apply @mul_right_cancel _ _ _ _ z⁻¹
  rw [mul_inv_cancel]
  exact h

/-! ### Sets of relations -/
def trivial_comm_rels {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R)
  := ⋃₀ (rels_of_trivial_commutator_of_root_pair R '' w.trivial_comm_root_pairs)

def single_comm_rels {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R)
  := ⋃₀ (rels_of_single_commutator_of_root_pair R '' w.single_comm_root_pairs)

def double_comm_rels {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R)
  := ⋃₀ (rels_of_double_commutator_of_root_pair R '' w.double_comm_root_pairs)

def mixed_commutes_rels {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R)
  := ⋃₀ (rels_of_mixed_commutes_of_root R '' w.mixed_commutes_roots)

def lin_rels {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R)
  := ⋃₀ (rels_of_lin_of_root R '' w.lin_roots)

def all_rels {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R)
  := ⋃₀ {trivial_comm_rels w, single_comm_rels w,  double_comm_rels w, mixed_commutes_rels w, lin_rels w, ⋃₀ w.nonhomog_rels_sets, ⋃₀ w.def_rels_sets}

/-! ### The group and the embedding -/

abbrev group {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R)
  := PresentedGroup (WeakChevalley.all_rels w)

def pres_mk {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R) :
  FreeGroupOnGradedGens Φ R →* (WeakChevalley.group w) := PresentedGroup.mk (WeakChevalley.all_rels w)

/-! ### Helpers -/

theorem trivial_commutator_helper {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R]
  (w : WeakChevalley Φ R) (ζ η : Φ) (h : (ζ, η) ∈ w.trivial_comm_root_pairs) :
  @trivial_commutator_of_root_pair (WeakChevalley.group w) _ Φ _ R _ (WeakChevalley.pres_mk w) ζ η := by
  intro i j hi hj t u
  apply eq_one_of_mem_rels
  simp only
  apply Set.mem_sUnion.mpr
  use (w.trivial_comm_rels)
  constructor
  · simpset
  · rw [trivial_comm_rels]
    apply Set.mem_sUnion.mpr
    use (rels_of_trivial_commutator_of_root_pair R (ζ, η))
    constructor
    · simp only [Set.mem_image]
      use (ζ, η)
    · rw [rels_of_trivial_commutator_of_root_pair]
      exists i, j, hi, hj, t, u

theorem single_commutator_helper {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R]
  (w : WeakChevalley Φ R) (ζ η θ : Φ) (C : R) (h_height : PosRootSys.height θ = PosRootSys.height ζ + PosRootSys.height η)
  (h : ⟨ ζ, η, θ, C, h_height ⟩ ∈ w.single_comm_root_pairs) :
  @single_commutator_of_root_pair (WeakChevalley.group w) _ Φ _ R _ (WeakChevalley.pres_mk w) ζ η θ C h_height := by
  intro i j hi hj t u
  apply helper
  apply eq_one_of_mem_rels
  simp only
  apply Set.mem_sUnion.mpr
  use (w.single_comm_rels)
  constructor
  · simpset
  · rw [single_comm_rels]
    apply Set.mem_sUnion.mpr
    use (rels_of_single_commutator_of_root_pair R ⟨ ζ, η, θ, C, h_height ⟩)
    constructor
    · simp only [Set.mem_image]
      use ⟨ ζ, η, θ, C, h_height ⟩
    · rw [rels_of_single_commutator_of_root_pair]
      exists i, j, hi, hj, t, u

theorem double_commutator_helper {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R]
  (w : WeakChevalley Φ R) (ζ η θ₁ θ₂ : Φ) (C₁ : R) (C₂ : R)
  (h₁_height : PosRootSys.height θ₁ = PosRootSys.height ζ + PosRootSys.height η)
  (h₂_height : PosRootSys.height θ₂ = PosRootSys.height ζ + 2 * PosRootSys.height η)
  (h : ⟨ ζ, η, θ₁, θ₂, C₁, C₂, h₁_height, h₂_height⟩ ∈ w.double_comm_root_pairs) :
  @double_commutator_of_root_pair (WeakChevalley.group w) _ Φ _ R _
  (WeakChevalley.pres_mk w) ζ η θ₁ θ₂ C₁ C₂ h₁_height h₂_height := by sorry

theorem mixed_commutes_helper {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R]
  (w : WeakChevalley Φ R) (ζ : Φ) (h : ζ ∈ w.mixed_commutes_roots) :
  @mixed_commutes_of_root (WeakChevalley.group w) _ Φ _ R _ (WeakChevalley.pres_mk w) ζ := by
  intro i j hi hj t u
  apply eq_one_of_mem_rels
  simp only
  apply Set.mem_sUnion.mpr
  use (w.mixed_commutes_rels)
  constructor
  · simpset
  · rw [mixed_commutes_rels]
    apply Set.mem_sUnion.mpr
    use (rels_of_mixed_commutes_of_root R ζ)
    constructor
    · simp only [Set.mem_image]
      use ζ
    · rw [rels_of_mixed_commutes_of_root]
      exists i, j, hi, hj, t, u

theorem lin_helper {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R]
  (w : WeakChevalley Φ R) (ζ : Φ) (h : ζ ∈ w.lin_roots) :
  @lin_of_root (WeakChevalley.group w) _ Φ _ R _ (WeakChevalley.pres_mk w) ζ := by
  intro i hi t u
  apply helper
  apply eq_one_of_mem_rels
  simp only
  apply Set.mem_sUnion.mpr
  use (w.lin_rels)
  constructor
  · simpset
  · rw [lin_rels]
    apply Set.mem_sUnion.mpr
    use (rels_of_lin_of_root R ζ)
    constructor
    · simp only [Set.mem_image]
      use ζ
    · rw [rels_of_lin_of_root]
      exists i, hi, t, u

theorem nonhomog_helper {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R) :
  ∀ S ∈ w.nonhomog_rels_sets, ∀ r ∈ S, WeakChevalley.pres_mk w r = (1 : WeakChevalley.group w) := by
  intro S h_S
  intro r h_r
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use ⋃₀ nonhomog_rels_sets w
  constructor
  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff, true_or, or_true]
  · apply Set.mem_sUnion.mpr
    use S

theorem def_helper {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R) :
  ∀ S ∈ w.def_rels_sets, ∀ r ∈ S, WeakChevalley.pres_mk w r = (1 : WeakChevalley.group w) := by
  intro S h_S
  intro r h_r
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use ⋃₀ def_rels_sets w
  constructor
  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff, true_or, or_true]
  · apply Set.mem_sUnion.mpr
    use S

end WeakChevalley
