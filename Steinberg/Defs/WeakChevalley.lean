import Mathlib.Algebra.Group.Commutator
import Mathlib.Algebra.Ring.Defs
import Mathlib.GroupTheory.Commutator.Basic
import Mathlib.GroupTheory.FreeGroup.Basic
import Mathlib.GroupTheory.PresentedGroup

import Steinberg.Defs.Root
import Steinberg.Defs.Chevalley
import Steinberg.Upstream.PresentedGroup

namespace Steinberg

open PosRootSys

variable {G : Type TG} [Group G]
         {Φ : Type TΦ} [PosRootSys Φ]
         {R : Type TR} [Ring R]

private theorem helperrr (G : Type TG) [Group G] (x y z : G) : x * y * z⁻¹ = 1 → x * y = z := by
  intro h
  apply @mul_right_cancel _ _ _ _ z⁻¹
  rw [mul_inv_cancel]
  exact h

macro (name := algebra) "simpset" : tactic => `(tactic| (simp only [Set.mem_insert_iff, Set.mem_union, Set.mem_setOf_eq, Set.mem_singleton_iff, true_or, or_true]))

open GradedGen

structure WeakChevalley (Φ : Type TΦ) [PosRootSys Φ] (R : Type TR) [Ring R] where
  mk ::
  -- autogenerated
  trivial_comm_root_pairs : Set (Φ × Φ)
  single_comm_root_pairs : Set (SingleSpanRootPair R Φ)
  mixed_commutes_roots : Set Φ
  lin_roots : Set Φ

  -- problem dependent
  nonhomog_rels : Set (Set (FreeGroupOnGradedGens Φ R))
  def_rels : Set (Set (FreeGroupOnGradedGens Φ R))

  nonhomog_rels_symm : ∀ S ∈ nonhomog_rels,
    FreeGroup.map (refl_deg_of_gen Φ R) '' S ⊆ S
  def_rels_symm : ∀ S ∈ def_rels,
    FreeGroup.map (refl_deg_of_gen Φ R) '' S ⊆ S

namespace WeakChevalley

open Steinberg

open WeakChevalley

/-! ### Sets of relations -/
def trivial_comm_rels {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R)
  := ⋃₀ (rels_of_trivial_commutator_of_root_pair R '' w.trivial_comm_root_pairs)

def single_comm_rels {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R)
  := ⋃₀ (rels_of_single_commutator_of_root_pair R '' w.single_comm_root_pairs)

def mixed_commutes_rels {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R)
  := ⋃₀ (rels_of_mixed_commutes_of_root R '' w.mixed_commutes_roots)

def lin_rels {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R)
  := ⋃₀ (rels_of_lin_of_root R '' w.lin_roots)

def all_rels {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R)
  := ⋃₀ {trivial_comm_rels w, single_comm_rels w, mixed_commutes_rels w, lin_rels w, ⋃₀ w.nonhomog_rels, ⋃₀ w.def_rels}

/-! ### The group and the embedding -/

abbrev group {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R)
  := PresentedGroup (WeakChevalley.all_rels w)

abbrev pres_mk {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R) :
  FreeGroupOnGradedGens Φ R →* (WeakChevalley.group w) := PresentedGroup.mk (WeakChevalley.all_rels w)

/-! ### Helpers -/

theorem trivial_commutator_helper {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R]
  (w : WeakChevalley Φ R) (ζ η : Φ) (h : (ζ, η) ∈ w.trivial_comm_root_pairs) :
  @trivial_commutator_of_root_pair (WeakChevalley.group w) _ Φ _ R _ (WeakChevalley.pres_mk w) ζ η := by
  intro i j hi hj t u
  apply eq_one_of_mem_rels
  simp only
  apply Set.mem_sUnion.mpr
  use (w.trivial_comm_rels)
  constructor
  · simpset
  · rw [trivial_comm_rels]
    apply Set.mem_sUnion.mpr
    use (rels_of_trivial_commutator_of_root_pair R (ζ, η))
    constructor
    · simp only [Set.mem_image]
      use (ζ, η)
    · rw [rels_of_trivial_commutator_of_root_pair]
      exists i, j, hi, hj, t, u

theorem single_commutator_helper {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R]
  (w : WeakChevalley Φ R) (ζ η θ : Φ) (C : R) (h_height : PosRootSys.height θ = PosRootSys.height ζ + PosRootSys.height η)
  (h : ⟨ ζ, η, θ, C, h_height ⟩ ∈ w.single_comm_root_pairs) :
  @single_commutator_of_root_pair (WeakChevalley.group w) _ Φ _ R _ (WeakChevalley.pres_mk w) ζ η θ C h_height := by
  intro i j hi hj t u
  apply helper
  apply eq_one_of_mem_rels
  simp only
  apply Set.mem_sUnion.mpr
  use (w.single_comm_rels)
  constructor
  · simpset
  · rw [single_comm_rels]
    apply Set.mem_sUnion.mpr
    use (rels_of_single_commutator_of_root_pair R ⟨ ζ, η, θ, C, h_height ⟩)
    constructor
    · simp only [Set.mem_image]
      use ⟨ ζ, η, θ, C, h_height ⟩
    · rw [rels_of_single_commutator_of_root_pair]
      exists i, j, hi, hj, t, u

theorem mixed_commutes_helper {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R]
  (w : WeakChevalley Φ R) (ζ : Φ) (h : ζ ∈ w.mixed_commutes_roots) :
  @mixed_commutes_of_root (WeakChevalley.group w) _ Φ _ R _ (WeakChevalley.pres_mk w) ζ := by
  intro i j hi hj t u
  apply eq_one_of_mem_rels
  simp only
  apply Set.mem_sUnion.mpr
  use (w.mixed_commutes_rels)
  constructor
  · simpset
  · rw [mixed_commutes_rels]
    apply Set.mem_sUnion.mpr
    use (rels_of_mixed_commutes_of_root R ζ)
    constructor
    · simp only [Set.mem_image]
      use ζ
    · rw [rels_of_mixed_commutes_of_root]
      exists i, j, hi, hj, t, u

theorem lin_helper {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R]
  (w : WeakChevalley Φ R) (ζ : Φ) (h : ζ ∈ w.lin_roots) :
  @lin_of_root (WeakChevalley.group w) _ Φ _ R _ (WeakChevalley.pres_mk w) ζ := by
  intro i hi t u
  apply helper
  apply eq_one_of_mem_rels
  simp only
  apply Set.mem_sUnion.mpr
  use (w.lin_rels)
  constructor
  · simpset
  · rw [lin_rels]
    apply Set.mem_sUnion.mpr
    use (rels_of_lin_of_root R ζ)
    constructor
    · simp only [Set.mem_image]
      use ζ
    · rw [rels_of_lin_of_root]
      exists i, hi, t, u

theorem nonhomog_helper {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R) :
  ∀ S ∈ w.nonhomog_rels, ∀ r ∈ S, WeakChevalley.pres_mk w r = (1 : WeakChevalley.group w) := by
  intro S h_S
  intro r h_r
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use ⋃₀ WeakChevalley.nonhomog_rels w
  constructor
  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff, true_or, or_true]
  · apply Set.mem_sUnion.mpr
    use S

theorem def_helper {Φ : Type TΦ} [PosRootSys Φ] {R : Type TR} [Ring R] (w : WeakChevalley Φ R) :
  ∀ S ∈ w.def_rels, ∀ r ∈ S, WeakChevalley.pres_mk w r = (1 : WeakChevalley.group w) := by
  intro S h_S
  intro r h_r
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use ⋃₀ WeakChevalley.def_rels w
  constructor
  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff, true_or, or_true]
  · apply Set.mem_sUnion.mpr
    use S

/-! # Reflection stuff -/

/-- Map a generator to its reflected image in the presented group (used to define the symmetry below). -/
def pres_of_refl_deg_of_gen (R : Type TR) [Ring R] (w : WeakChevalley Φ R) (g : GradedGen Φ R) : WeakChevalley.group w :=
  WeakChevalley.pres_mk w (free_mk (refl_deg_of_gen Φ R g))

-- theorem helper {SS : Set (Set (FreeGroupOnGradedGens Φ R))} {f : FreeGroupOnGradedGens Φ R → FreeGroupOnGradedGens Φ R}
--   : (∀ S ∈ SS, f '' S ⊆ S) → f '' (⋃₀ SS) ⊆ ⋃₀ SS := by
--   intro h
--   rw [Set.image_sUnion]
--   apply Set.sUnion_subset
--   intro S'
--   simp only [Set.mem_image]
--   intro h
--   rcases h with ⟨ x, ⟨ h1, h2 ⟩ ⟩
--   rw [← h2]
--   have this1 : f '' x ⊆ x := by exact h x h1
--   have this2 : x ⊆ ⋃₀ SS := by exact Set.subset_sUnion_of_mem h1
--   exact Set.Subset.trans this1 this2

-- slightly ugly...
private theorem reflect_degree_of_weak_rels' :
  FreeGroup.lift (FreeGroup.of ∘ (refl_deg_of_gen Φ R)) '' (WeakChevalley.all_rels w) ⊆ (WeakChevalley.all_rels w) := by
  sorry
  -- rw [all_rels]
  -- apply helper
  -- intro S h_S
  -- simp at h_S
  -- rcases h_S with h_triv | h_sing | h_mixed | h_lin | h_nonhomog | h_lin
  -- · rw [h_triv]
  --   rw [trivial_comm_rels]
  --   apply helper
  --   intro S h_S
  --   simp at h_S
  --   rcases h_S with ⟨ ζ, η, ⟨ h1, h2 ⟩ ⟩
  --   rw [← h2]
  --   rw [Set.subset_def]
  --   intro x h_x
  --   exact @refl_deg_of_rels_of_trivial_commutator_of_root_pair Φ _ R _ ζ η


theorem reflect_degree_of_weak_rels :
  FreeGroup.lift (FreeGroup.of ∘ (refl_deg_of_gen Φ R)) '' (WeakChevalley.all_rels w) ⊆ Subgroup.normalClosure (WeakChevalley.all_rels w) := by
  exact Set.Subset.trans reflect_degree_of_weak_rels' Subgroup.subset_normalClosure

def refl_symm (R : Type TR) [Ring R] (w : WeakChevalley Φ R) : WeakChevalley.group w →* WeakChevalley.group w :=
  toPresentedGroup reflect_degree_of_weak_rels

/- Calculates the image of a generator in the presented group by the degree-reflection homomorphism. -/
theorem refl_im (ζ : Φ) (i : ℕ) (hi : i ≤ PosRootSys.height ζ) (t : R) (w : WeakChevalley Φ R) :
  refl_symm R w (WeakChevalley.pres_mk w (free_mk_mk ζ i hi t)) =
    (WeakChevalley.pres_mk w (free_mk_mk ζ (PosRootSys.height ζ - i) (by omega) t)) := by
  simp only [refl_symm, WeakChevalley.pres_mk, free_mk_mk]
  rw [← PresentedGroup.of, toPresentedGroup.of]
  simp only [FreeGroup.lift.of, Function.comp_apply]
  rw [refl_deg_of_gen]

end WeakChevalley
