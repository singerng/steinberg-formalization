/-

LICENSE goes here.

-/

import Steinberg.Defs.Chevalley
import Steinberg.Upstream.PresentedGroup

/-!

  File dox go here.

-/

namespace Steinberg

open PosRootSys GradedGen

variable {G : Type TG} [Group G]
         {Φ : Type TΦ} [PosRootSys Φ]
         {R : Type TR} [Ring R]

macro (name := algebra) "simpset" : tactic => `(tactic|
    simp only [Set.mem_insert_iff, Set.mem_union, Set.mem_setOf_eq,
      Set.mem_singleton_iff, true_or, or_true]
  )

structure WeakChevalley (Φ : Type TΦ) [PosRootSys Φ] (R : Type TR) [Ring R] where
  mk ::
  -- autogenerated
  trivial_comm_root_pairs : Set (Φ × Φ)
  single_comm_root_pairs : Set (SingleSpanRootPair Φ R)
  double_comm_root_pairs : Set (DoubleSpanRootPair Φ R)
  mixed_commutes_roots : Set Φ
  lin_roots : Set Φ

  -- problem dependent
  nonhomog_rels_sets : Set (Set (FreeGroupOnGradedGens Φ R))
  def_rels_sets : Set (Set (FreeGroupOnGradedGens Φ R))

namespace WeakChevalley

open Steinberg

open WeakChevalley

/-! ### Sets of relations -/
def trivial_comm_rels (w : WeakChevalley Φ R) :=
  ⋃₀ (rels_of_trivial_commutator_of_root_pair R '' w.trivial_comm_root_pairs)

def single_comm_rels (w : WeakChevalley Φ R) :=
  ⋃₀ (rels_of_single_commutator_of_root_pair '' w.single_comm_root_pairs)

def double_comm_rels (w : WeakChevalley Φ R) :=
  ⋃₀ (rels_of_double_commutator_of_root_pair '' w.double_comm_root_pairs)

def mixed_commutes_rels (w : WeakChevalley Φ R) :=
  ⋃₀ (rels_of_mixed_commutes_of_root R '' w.mixed_commutes_roots)

def lin_rels (w : WeakChevalley Φ R)
  := ⋃₀ (rels_of_lin_of_root R '' w.lin_roots)

def all_rels (w : WeakChevalley Φ R) :=
  ⋃₀ {trivial_comm_rels w, single_comm_rels w, double_comm_rels w, mixed_commutes_rels w,
      lin_rels w, ⋃₀ w.nonhomog_rels_sets, ⋃₀ w.def_rels_sets}

/-! ### The group and the embedding -/

abbrev group (w : WeakChevalley Φ R) :=
  PresentedGroup (WeakChevalley.all_rels w)

def pres_mk (w : WeakChevalley Φ R) : FreeGroupOnGradedGens Φ R →* group w :=
  PresentedGroup.mk (WeakChevalley.all_rels w)

/-! ### Helpers -/

theorem trivial_commutator_helper {w : WeakChevalley Φ R} {ζ η : Φ}
    (h : (ζ, η) ∈ w.trivial_comm_root_pairs)
      : trivial_commutator_of_root_pair w.pres_mk ζ η := by
  intro i j hi hj t u
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use w.trivial_comm_rels
  constructor
  · simpset
  · rw [trivial_comm_rels]
    apply Set.mem_sUnion.mpr
    use rels_of_trivial_commutator_of_root_pair R (ζ, η)
    constructor
    · simp only [Set.mem_image]
      use (ζ, η)
    · rw [rels_of_trivial_commutator_of_root_pair]
      exists i, j, hi, hj, t, u

-- TODO: Move this to a different file?
theorem helper {x y z : G} : x * y * z⁻¹ = 1 → x * y = z := by
  intro h
  apply @mul_right_cancel _ _ _ _ z⁻¹
  rw [mul_inv_cancel]
  exact h

theorem single_commutator_helper (w : WeakChevalley Φ R) (ζ η θ : Φ) (C : R)
  (h_height : height θ = PosRootSys.height ζ + PosRootSys.height η)
  (h : ⟨ ζ, η, θ, C, h_height ⟩ ∈ w.single_comm_root_pairs)
    : single_commutator_of_root_pair w.pres_mk ζ η θ C h_height := by
  intro i j hi hj t u
  apply helper
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use w.single_comm_rels
  constructor
  · simpset
  · rw [single_comm_rels]
    apply Set.mem_sUnion.mpr
    use (rels_of_single_commutator_of_root_pair ⟨ ζ, η, θ, C, h_height ⟩)
    constructor
    · simp only [Set.mem_image]
      use ⟨ ζ, η, θ, C, h_height ⟩
    · rw [rels_of_single_commutator_of_root_pair]
      exists i, j, hi, hj, t, u

theorem double_commutator_helper (w : WeakChevalley Φ R) (ζ η θ₁ θ₂ : Φ) (C₁ C₂ : R)
  (h_height₁ : height θ₁ = PosRootSys.height ζ + PosRootSys.height η)
  (h_height₂ : height θ₂ = PosRootSys.height ζ + 2 * PosRootSys.height η)
  (h : ⟨ ζ, η, θ₁, θ₂, C₁, C₂, h_height₁, h_height₂ ⟩ ∈ w.double_comm_root_pairs)
    : double_commutator_of_root_pair w.pres_mk ζ η θ₁ θ₂ C₁ C₂ h_height₁ h_height₂ := by
  intro i j hi hj t u
  apply helper
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use w.double_comm_rels
  constructor
  · simpset
  · rw [double_comm_rels]
    apply Set.mem_sUnion.mpr
    use (rels_of_double_commutator_of_root_pair ⟨ ζ, η, θ₁, θ₂, C₁, C₂, h_height₁, h_height₂ ⟩)
    constructor
    · simp only [Set.mem_image]
      use ⟨ ζ, η, θ₁, θ₂, C₁, C₂, h_height₁, h_height₂ ⟩
    · rw [rels_of_double_commutator_of_root_pair]
      exists i, j, hi, hj, t, u

theorem mixed_commutes_helper (w : WeakChevalley Φ R)
  {ζ : Φ} (h : ζ ∈ w.mixed_commutes_roots)
    : mixed_commutes_of_root w.pres_mk ζ := by
  intro i j hi hj t u
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use w.mixed_commutes_rels
  constructor
  · simpset
  · rw [mixed_commutes_rels]
    apply Set.mem_sUnion.mpr
    use rels_of_mixed_commutes_of_root R ζ
    constructor
    · simp only [Set.mem_image]
      use ζ
    · rw [rels_of_mixed_commutes_of_root]
      exists i, j, hi, hj, t, u

theorem lin_helper (w : WeakChevalley Φ R) {ζ : Φ} (h : ζ ∈ w.lin_roots)
    : lin_of_root w.pres_mk ζ := by
  intro i hi t u
  apply helper
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use w.lin_rels
  constructor
  · simpset
  · rw [lin_rels]
    apply Set.mem_sUnion.mpr
    use rels_of_lin_of_root R ζ
    constructor
    · simp only [Set.mem_image]
      use ζ
    · rw [rels_of_lin_of_root]
      exists i, hi, t, u

theorem nonhomog_helper (w : WeakChevalley Φ R)
    : ∀ S ∈ w.nonhomog_rels_sets, ∀ r ∈ S, w.pres_mk r = 1 := by
  intro S _ _ _
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use ⋃₀ nonhomog_rels_sets w
  constructor
  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff, true_or, or_true]
  · apply Set.mem_sUnion.mpr
    use S

theorem def_helper (w : WeakChevalley Φ R)
    : ∀ S ∈ w.def_rels_sets, ∀ r ∈ S, w.pres_mk r = 1 := by
  intro S _ _ _
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use ⋃₀ def_rels_sets w
  constructor
  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff, true_or, or_true]
  · apply Set.mem_sUnion.mpr
    use S

end WeakChevalley
