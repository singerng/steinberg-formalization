/-

LICENSE goes here.

-/

import Steinberg.Defs.Chevalley
import Steinberg.Defs.Commutator
import Steinberg.Upstream.PresentedGroup
import Steinberg.Macro.Group
import Steinberg.Macro.Syntax

/-!

  File dox go here.

-/

namespace Steinberg

open PosRootSys GradedGen

variable {G : Type TG} [Group G]
         {Φ : Type TΦ} [PosRootSys Φ]
         {R : Type TR} [Ring R]

macro (name := algebra) "simpset" : tactic => `(tactic|
    simp only [Set.mem_insert_iff, Set.mem_union, Set.mem_setOf_eq,
      Set.mem_singleton_iff, true_or, or_true]
  )

structure WeakChevalley (Φ : Type TΦ) [PosRootSys Φ] (R : Type TR) [Ring R] where
  mk ::
  -- autogenerated
  trivial_comm_root_pairs : Set (Φ × Φ)
  single_comm_root_pairs : Set (SingleSpanRootPair Φ R)
  double_comm_root_pairs : Set (DoubleSpanRootPair Φ R)
  mixed_commutes_roots : Set Φ
  lin_roots : Set Φ

  -- problem dependent
  nonhomog_rels_sets : Set (Set (FreeGroupOnGradedGens Φ R))
  def_rels_sets : Set (Set (FreeGroupOnGradedGens Φ R))

namespace WeakChevalley

open Steinberg

open WeakChevalley

/-! ### Sets of relations -/
def trivial_comm_rels (w : WeakChevalley Φ R) :=
  ⋃₀ (rels_of_trivial_commutator_of_root_pair R '' w.trivial_comm_root_pairs)

def single_comm_rels (w : WeakChevalley Φ R) :=
  ⋃₀ (rels_of_single_commutator_of_root_pair '' w.single_comm_root_pairs)

def double_comm_rels (w : WeakChevalley Φ R) :=
  ⋃₀ (rels_of_double_commutator_of_root_pair '' w.double_comm_root_pairs)

def mixed_commutes_rels (w : WeakChevalley Φ R) :=
  ⋃₀ (rels_of_mixed_commutes_of_root R '' w.mixed_commutes_roots)

def lin_rels (w : WeakChevalley Φ R) :=
  ⋃₀ (rels_of_lin_of_root R '' w.lin_roots)

def all_rels (w : WeakChevalley Φ R) :=
  ⋃₀ {trivial_comm_rels w, single_comm_rels w, double_comm_rels w, mixed_commutes_rels w,
      lin_rels w, ⋃₀ nonhomog_rels_sets w, ⋃₀ def_rels_sets w}

/-! ### The group and the embedding -/

abbrev group (w : WeakChevalley Φ R) :=
  PresentedGroup (WeakChevalley.all_rels w)

def pres_mk (w : WeakChevalley Φ R) : FreeGroupOnGradedGens Φ R →* group w :=
  PresentedGroup.mk (WeakChevalley.all_rels w)

open Lean PrettyPrinter Delaborator SubExpr in
/--
  Delaborator for `pres_mk` when it's an application.

  Note that this will obscure the widgets on the infoview, such that
  hovering over the group elements won't bring you back to `pres_mk`.
-/
@[delab app.DFunLike.coe]
def delab_pres_mk' : Delab := do
  withOverApp 6 do
    let e ← getExpr
    let mkApp5 (.const ``pres_mk _) _ _ _ _ _ := e.appFn!.appArg!' | failure
    let f_mk_mk ← withNaryArg 5 delab
    `($f_mk_mk)

/-! ### Helpers -/

theorem trivial_commutator_helper {w : WeakChevalley Φ R} {ζ η : Φ}
    (h : (ζ, η) ∈ w.trivial_comm_root_pairs)
      : trivial_commutator_of_root_pair w.pres_mk ζ η := by
  intro i j hi hj t u
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use w.trivial_comm_rels
  constructor
  · simpset
  · rw [trivial_comm_rels]
    apply Set.mem_sUnion.mpr
    use rels_of_trivial_commutator_of_root_pair R (ζ, η)
    constructor
    · simp only [Set.mem_image]
      use (ζ, η)
    · rw [rels_of_trivial_commutator_of_root_pair]
      exists i, j, hi, hj, t, u

-- TODO: Move this to a different file?
theorem helper {x y z : G} : x * y * z⁻¹ = 1 → x * y = z := by
  intro h
  apply @mul_right_cancel _ _ _ _ z⁻¹
  rw [mul_inv_cancel]
  exact h

theorem single_commutator_helper (w : WeakChevalley Φ R) (ζ η θ : Φ) (C : R)
  (h_height : height θ = height ζ + height η)
  (h : ⟨ ζ, η, θ, C, h_height ⟩ ∈ w.single_comm_root_pairs)
    : single_commutator_of_root_pair w.pres_mk ζ η θ C h_height := by
  intro i j hi hj t u
  apply helper
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use w.single_comm_rels
  constructor
  · simpset
  · rw [single_comm_rels]
    apply Set.mem_sUnion.mpr
    use (rels_of_single_commutator_of_root_pair ⟨ ζ, η, θ, C, h_height ⟩)
    constructor
    · simp only [Set.mem_image]
      use ⟨ ζ, η, θ, C, h_height ⟩
    · rw [rels_of_single_commutator_of_root_pair]
      exists i, j, hi, hj, t, u

theorem double_commutator_helper (w : WeakChevalley Φ R) (ζ η θ₁ θ₂ : Φ) (C₁ C₂ : R)
  (h_height₁ : height θ₁ = height ζ + height η)
  (h_height₂ : height θ₂ = height ζ + 2 * height η)
  (h : ⟨ ζ, η, θ₁, θ₂, C₁, C₂, h_height₁, h_height₂ ⟩ ∈ w.double_comm_root_pairs)
    : double_commutator_of_root_pair w.pres_mk ζ η θ₁ θ₂ C₁ C₂ h_height₁ h_height₂ := by
  intro i j hi hj t u
  apply helper
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use w.double_comm_rels
  constructor
  · simpset
  · rw [double_comm_rels]
    apply Set.mem_sUnion.mpr
    use (rels_of_double_commutator_of_root_pair ⟨ ζ, η, θ₁, θ₂, C₁, C₂, h_height₁, h_height₂ ⟩)
    constructor
    · simp only [Set.mem_image]
      use ⟨ ζ, η, θ₁, θ₂, C₁, C₂, h_height₁, h_height₂ ⟩
    · rw [rels_of_double_commutator_of_root_pair]
      exists i, j, hi, hj, t, u

theorem mixed_commutes_helper (w : WeakChevalley Φ R)
  {ζ : Φ} (h : ζ ∈ w.mixed_commutes_roots)
    : mixed_commutes_of_root w.pres_mk ζ := by
  intro i j hi hj t u
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use w.mixed_commutes_rels
  constructor
  · simpset
  · rw [mixed_commutes_rels]
    apply Set.mem_sUnion.mpr
    use rels_of_mixed_commutes_of_root R ζ
    constructor
    · simp only [Set.mem_image]
      use ζ
    · rw [rels_of_mixed_commutes_of_root]
      exists i, j, hi, hj, t, u

theorem lin_helper (w : WeakChevalley Φ R) {ζ : Φ} (h : ζ ∈ w.lin_roots)
    : lin_of_root(w.pres_mk, ζ) := by
  intro i hi t u
  apply helper
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use w.lin_rels
  constructor
  · simpset
  · rw [lin_rels]
    apply Set.mem_sUnion.mpr
    use rels_of_lin_of_root R ζ
    constructor
    · simp only [Set.mem_image]
      use ζ
    · rw [rels_of_lin_of_root]
      exists i, hi, t, u

theorem nonhomog_helper (w : WeakChevalley Φ R)
    : ∀ S ∈ w.nonhomog_rels_sets, ∀ r ∈ S, w.pres_mk r = 1 := by
  intro S _ _ _
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use ⋃₀ nonhomog_rels_sets w
  constructor
  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff, true_or, or_true]
  · apply Set.mem_sUnion.mpr
    use S

theorem def_helper (w : WeakChevalley Φ R)
    : ∀ S ∈ w.def_rels_sets, ∀ r ∈ S, w.pres_mk r = 1 := by
  intro S _ _ _
  apply eq_one_of_mem_rels
  apply Set.mem_sUnion.mpr
  use ⋃₀ def_rels_sets w
  constructor
  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff, true_or, or_true]
  · apply Set.mem_sUnion.mpr
    use S

section declareThms

open Lean Parser.Tactic
set_option hygiene false

macro "declare_triv_expr_thm" w:ident R:term:arg r₁:term:arg r₂:term:arg : command => do
  let exprAs := TSyntax.mapIdent₂ r₁ r₂
    (fun s₁ s₂ => "expr_" ++ s₁ ++ "_" ++ s₂ ++ "_as_" ++ s₂ ++ "_" ++ s₁)
  let commName := TSyntax.mapIdent₂ r₁ r₂
    (fun s₁ s₂ => "comm_of_" ++ s₁ ++ "_" ++ s₂)
  let commOf ← `(rwRule| $commName:term)
  let cmds ← Syntax.getArgs <$> `(
    section

    @[group_reassoc] theorem $exprAs
       : ∀ ⦃i j : ℕ⦄ (hi : i ≤ height $r₁) (hj : j ≤ height $r₂) (t u : $R),
        commutes(($w $R).pres_mk {$r₁:term, i, t},
                 ($w $R).pres_mk {$r₂:term, j, u}) := by
      intro i j hi hj t u
      apply triv_comm_iff_commutes.mp
      rw [$commOf]
      try assumption

    end
  )
  return ⟨mkNullNode cmds⟩

macro "declare_triv_comm_of_root_pair_thms" w:ident R:term:arg r₁:term:arg r₂:term:arg : command => do
  let commOf := TSyntax.mapIdent₂ r₁ r₂ (fun s₁ s₂ => "comm_of_" ++ s₁ ++ "_" ++ s₂)
  let cmds ← Syntax.getArgs <$> `(
    section

    theorem $commOf : trivial_commutator_of_root_pair ($w $R).pres_mk $r₁ $r₂ :=
      ($w $R).trivial_commutator_helper (by unfold $w; simp)

    declare_triv_expr_thm $w $R $r₁ $r₂

    end
  )
  return ⟨mkNullNode cmds⟩

macro "declare_single_expr_thms" w:ident R:term:arg r₁:term:arg r₂:term:arg r₃:term:arg n:num : command => do
  let innerTerm ←
    if n.getNat = 1 then `(t * u)
    else                 `($n * t * u)
  let commOf := TSyntax.mapIdent₂ r₁ r₂ (fun s₁ s₂ => "comm_of_" ++ s₁ ++ "_" ++ s₂)
  let exprAs := TSyntax.mapIdent₃ r₁ r₂ r₃
    (fun s₁ s₂ s₃ => "expr_" ++ s₃ ++ "_as_" ++ s₁ ++ "_" ++ s₂ ++ "_" ++ s₁ ++ "_" ++ s₂)
  let exprAsRev := TSyntax.mapIdent₃ r₁ r₂ r₃
    (fun s₁ s₂ s₃ => "expr_" ++ s₁ ++ "_" ++ s₂ ++ "_as_" ++ s₃ ++ "_" ++ s₂ ++ "_" ++ s₁)
  let cmds ← Syntax.getArgs <$> `(
    section

    theorem $exprAs
      : ∀ ⦃i j : ℕ⦄ (hi : i ≤ height $r₁) (hj : j ≤ height $r₂) (t u : $R),
        (($w $R).pres_mk
          (free_mk_mk $r₃ (i + j) (by ht) $innerTerm))
          = ($w $R).pres_mk {$r₁:term, i, t}
            * ($w $R).pres_mk {$r₂:term, j, u}
            * ($w $R).pres_mk {$r₁:term, i, -t}
            * ($w $R).pres_mk {$r₂:term, j, -u} := by
      intro i j hi hj t u
      have := $commOf hi hj t u
      chev_simp [commutatorElement_def, one_mul, mul_one] at this
      symm at this
      exact this

    @[group_reassoc]
    theorem $exprAsRev
      : ∀ ⦃i j : ℕ⦄ (hi : i ≤ height $r₁) (hj : j ≤ height $r₂) (t u : $R),
        reorder_left(
          ($w $R).pres_mk {$r₁:term, i, t},
          ($w $R).pres_mk {$r₂:term, j, u},
          (($w $R).pres_mk
            (free_mk_mk $r₃ (i + j) (by ht) $innerTerm))
        ) := by
      intro i j hi hj t u
      have := $commOf hi hj t u
      chev_simp [commutatorElement_def, one_mul, mul_one] at this
      grw [← this]

      end
  )
  return ⟨mkNullNode cmds⟩

macro "declare_single_comm_of_root_pair_thms" w:ident R:term:arg r₁:term:arg r₂:term:arg r₃:term:arg n:num : command => do
  let commOf := TSyntax.mapIdent₂ r₁ r₂ (fun s₁ s₂ => "comm_of_" ++ s₁ ++ "_" ++ s₂)
  let cmds ← Syntax.getArgs <$> `(
    section

    theorem $commOf : single_commutator_of_root_pair ($w $R).pres_mk $r₁ $r₂ $r₃ $n rfl :=
      ($w $R).single_commutator_helper $r₁ $r₂ $r₃ $n rfl (by unfold $w; simp)

    declare_single_expr_thms $w $R $r₁ $r₂ $r₃ $n

    end
  )
  return ⟨mkNullNode cmds⟩

macro "declare_lin_id_inv_thms" w:ident R:term:arg root:term:arg : command => do
  let linOf := root.mapIdent ("lin_of_" ++ ·)
  let idOf := root.mapIdent ("id_of_" ++ ·)
  let invOf := root.mapIdent ("inv_of_" ++ ·)
  let cmds ← Syntax.getArgs <$> `(
    section

    @[group_reassoc (attr := simp, chev_simps)]
    theorem $linOf : lin_of_root(($w $R).pres_mk, $root) :=
      WeakChevalley.lin_helper ($w $R)
        (by unfold $w; simp [trivial_commutator_pairs])

    @[simp, chev_simps]
    theorem $idOf : id_of_root(($w $R).pres_mk, $root) :=
      id_of_lin_of_root $linOf

    @[simp, chev_simps]
    theorem $invOf : inv_of_root(($w $R).pres_mk, $root) :=
      inv_of_lin_of_root $linOf

    end
  )
  return ⟨mkNullNode cmds⟩

macro "declare_mixed_expr_thm" w:ident R:term:arg r:term:arg : command => do
  let mixedName := r.mapIdent ("comm_of_" ++ ·)
  let mixedRw ← `(rwRule| $mixedName:term)
  let exprName := r.mapIdent (fun s => "expr_" ++ s ++ "_" ++ s ++ "_as_" ++ s ++ "_" ++ s)
  let cmds ← Syntax.getArgs <$> `(
    section

    @[group_reassoc]
    theorem $exprName :
        ∀ ⦃i j : ℕ⦄ (hi : i ≤ height $r) (hj : j ≤ height $r) (t u : $R),
          commutes(($w $R).pres_mk {$r:term, i, t},
                   ($w $R).pres_mk {$r:term, j, u}) := by
      intro i j hi hj t u
      apply triv_comm_iff_commutes.mp
      rw [$mixedRw]
      try assumption

    end
  )
  return ⟨mkNullNode cmds⟩

macro "declare_mixed_comm_thms" w:ident R:term:arg r:term:arg : command => do
  let mixedName := r.mapIdent ("comm_of_" ++ ·)
  let cmds ← Syntax.getArgs <$> `(
    section

    theorem $mixedName : mixed_commutes_of_root ($w $R).pres_mk $r :=
      WeakChevalley.mixed_commutes_helper ($w $R)
        (by unfold $w; simp [trivial_commutator_pairs])

    declare_mixed_expr_thm $w $R $r

    end
  )
  return ⟨mkNullNode cmds⟩

-- r₁ is the larger root, as opposed to the above macros
macro "declare_reflected_thm" w:ident R:term:arg v:term:arg
        r₁:term:arg r₂:term:arg r₃:term:arg isNeg:num C:num
        n₁:num n₂:num n₃:num n₄:num n₅:num n₆:num : command => do
  let innerTerm ←
    match isNeg.getNat, C.getNat with
    | 0, 1 => `(t * u)
    | 1, 1 => `(-t * u)
    | 0, _ => `($C * t * u)
    | 1, _ => `(-$C * t * u)
    | _, _ => `($C * t * u)
  let exprName := TSyntax.mapIdent₃ r₁ r₂ r₃
    (fun s₁ s₂ s₃ => "expr_" ++ s₁ ++ "_as_comm_of_" ++ s₂ ++ "_" ++ s₃ ++ s!"_{n₂.getNat}{n₃.getNat}")
  let exprLemma := TSyntax.mapIdent₃ r₁ r₂ r₃
    (fun s₁ s₂ s₃ => "expr_" ++ s₁ ++ "_as_comm_of_" ++ s₂ ++ "_" ++ s₃ ++ s!"_{n₅.getNat}{n₆.getNat}")
  let exprLemmaRw ← `(rwRule| $exprLemma:term)
  let cmds ← Syntax.getArgs <$> `(
    section

    lemma $exprName :
        ∀ (t u : $R),
          (($w $R).pres_mk {$r₁:term, $n₁, $innerTerm})
            = ⁅($w $R).pres_mk {$r₂:term, $n₂, t}, ($w $R).pres_mk {$r₃:term, $n₃, u}⁆ := by
      intro t u
      have : ($w $R).pres_mk {$r₁:term, $n₁, $innerTerm}
        = ReflDeg.refl_symm $v (($w $R).pres_mk {$r₁:term, $n₄, $innerTerm}) := rfl
      rw [this]; clear this
      have : ⁅($w $R).pres_mk {$r₂:term, $n₂, t}, ($w $R).pres_mk {$r₃:term, $n₃, u}⁆
          = ReflDeg.refl_symm $v
              ⁅($w $R).pres_mk {$r₂:term, $n₅, t}, ($w $R).pres_mk {$r₃:term, $n₆, u}⁆ := by
        rw [map_commutatorElement]; trivial
      rw [this, $exprLemmaRw]
      <;> try assumption

    end
  )
  return ⟨mkNullNode cmds⟩

macro "declare_triv_comm_reflected_thm" w:ident R:term:arg v:term:arg
        r₁:term:arg r₂:term:arg
        n₁:num n₂:num n₃:num n₄:num : command => do
  let commOf := TSyntax.mapIdent₂ r₁ r₂
    (fun s₁ s₂ => "comm_of_" ++ s₁ ++ "_" ++ s₂ ++ s!"_{n₁.getNat}{n₂.getNat}")
  let commLemma := TSyntax.mapIdent₂ r₁ r₂
    (fun s₁ s₂ => "comm_of_" ++ s₁ ++ "_" ++ s₂ ++ s!"_{n₃.getNat}{n₄.getNat}")
  let commLemmaRw ← `(rwRule| $commLemma:term)
  let cmds ← Syntax.getArgs <$> `(
    section

    lemma $commOf : ∀ (t u : $R),
        ⁅ ($w $R).pres_mk {$r₁:term, $n₁, t}, ($w $R).pres_mk {$r₂:term, $n₂, u} ⁆ = 1 := by
      intro t u
      have : ⁅ ($w $R).pres_mk {$r₁:term, $n₁, t}, ($w $R).pres_mk {$r₂:term, $n₂, u} ⁆
        = ReflDeg.refl_symm $v
            ⁅ ($w $R).pres_mk {$r₁:term, $n₃, t}, ($w $R).pres_mk {$r₂:term, $n₄, u} ⁆ := by
        rw [map_commutatorElement]; trivial
      rw [this, $commLemmaRw]
      <;> try assumption

    end
  )
  return ⟨mkNullNode cmds⟩

end declareThms /- section -/

end WeakChevalley
